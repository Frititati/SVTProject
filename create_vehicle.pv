(* Types Definition                                                              *)
type keymat.                                    (*' Key Material                 *)
type key.                                       (*' Symmetric key                *)
type pri_key.                                   (*' Private key                  *)
type pub_key.                                   (*' Public key                   *)
type result.

type cert.                                      (*' Certificate                  *)
type enrollment_cert.                           (*' Enrollment Certificate       *)
type butterfly_cert.                            (*' Bufferfly Certificate        *)

type pseudonym_request.                         (*' Pseudonym Request            *)

(* Channels                                                                      *)
free pub_ch:channel.                            (*' the public channel           *)
free pri_ch:channel.                            (*' the private channel          *)

(* Utilities                                                                     *)
fun gen_pub_key(keymat): pub_key.
fun gen_pri_key(keymat): pri_key.

(* Digital Signature                                                             *)
fun sign(bitstring, pri_key):bitstring.
fun ok():result.
reduc forall m:bitstring, smat:keymat; get_message_sign(sign(m,gen_pri_key(smat))) = m.
reduc forall m:bitstring, smat:keymat; check_sign(sign(m, gen_pri_key(smat)), gen_pub_key(smat)) = ok().

(* Asymmetric encryption                                                         *)
fun aenc(bitstring, pub_key):bitstring.
reduc forall m:bitstring, smat:keymat; adec(aenc(m, gen_pub_key(smat)), gen_pri_key(smat)) = m.

(* Butterfly                                                                     *)
fun but_expand(bitstring): bitstring.
fun but_add(bitstring, bitstring): bitstring.
fun but_keymat(bitstring, bitstring): keymat.
fun but_to_pub_key(bitstring): pub_key.
fun but_to_pri_key(bitstring): pri_key.

(* Generic Cert                                                                  *)
fun make_cert(bitstring, pub_key, pri_key):cert [private].
reduc forall id:bitstring, pub:pub_key, pri:pri_key; get_cert_pub_key(make_cert(id, pub, pri)) = pub.
reduc forall id:bitstring, pub:pub_key, pri:pri_key; get_cert_id(make_cert(id, pub, pri)) = id.
reduc forall id:bitstring, pub:pub_key, smat:keymat; check_cert(make_cert(id, pub, gen_pri_key(smat)), gen_pub_key(smat)) = ok().

(* Added Experimental Butterfly extension functions                              *)
reduc forall m:bitstring, a:bitstring, b:bitstring; but_adec(aenc(m, but_to_pub_key(but_add(but_expand(a), but_expand(b)))), but_to_pri_key(but_add(a, b))) = m.
reduc forall m:bitstring, a:bitstring, b:bitstring, c:bitstring; but_check_sign(sign(m, but_to_pri_key(but_add(but_add(a, b), c))), but_to_pub_key(but_add(but_add(but_expand(a), but_expand(b)), but_expand(c)))) = ok().

(*
reduc forall id:bitstring, a:bitstring, b:bitstring, c:bitstring, pub:pub_key; but_check_cert(make_cert(id, pub, but_to_pri_key(but_add(but_add(a, b), c))), but_to_pub_key(but_add(but_add(but_expand(a), but_expand(b)), but_expand(c)))) = ok().
*)

(*
	fun everify(esign(m, plus(a,fk,c)), m, plus(plus(epk(a), epk(fk)), epk(c))) = etrue,
	fun everify(butterfly_sign(m, but_add(but_add(a,b),c)), m, but_add(but_add(but_expand(a), but_expand(b)), but_expand(c))) = ok().
*)

(* OBE Enrollment Cert                                                           
	fun make_enrollment_cert(bitstring, pub_key, pri_key):enrollment_cert [private].
	reduc forall id:bitstring, pub:pub_key, pri:pri_key; get_enrollment_cert_pub_key(make_enrollment_cert(id, pub, pri)) = pub.
	reduc forall id:bitstring, pub:pub_key, pri:pri_key; get_enrollment_cert_id(make_enrollment_cert(id, pub, pri)) = id.
*)

(* Butterfly Cert                                                                
	fun make_butterfly_cert(bitstring, pub_key):butterfly_cert [private].
	reduc forall id:bitstring, pub:pub_key; get_butterfly_cert_pub_key(make_butterfly_cert(id, pub)) = pub.
	reduc forall id:bitstring, pub:pub_key; get_butterfly_cert_id(make_butterfly_cert(id, pub)) = id.
*)

event Received_Valid_Pseudonym_Request_RA(bitstring).
event Sent_Valid_Pseudonym_Request_OBE(bitstring).
event Sent_Valid_Message(bitstring).
event Received_Valid_Message(bitstring).

event Test(bitstring).

(*  Other Queries
	query request:bitstring; event(Received_Valid_Pseudonym_Request_RA(request)).

	query message:bitstring; event(Sent_Valid_Message(message)).
	query message:bitstring; event(Received_Valid_Message(message)).
*)

query message:bitstring; event(Test(message)).

query request:bitstring; event(Sent_Valid_Pseudonym_Request_OBE(request)).

query request:bitstring; event(Received_Valid_Pseudonym_Request_RA(request)) ==> event(Sent_Valid_Pseudonym_Request_OBE(request)).
query message:bitstring; event(Received_Valid_Message(message)) ==> event(Sent_Valid_Message(message)).

let OBESendMessages(pseudonym_cert:cert, pseudonym_pri_key:pri_key) = 
	(* OBE can send multiple messages with the same pseudocert                   *)
	!(	(* Broadcast message to send *)
		new message:bitstring;
		(* Sign the message                                                      *)
		let signed_message = sign(message, pseudonym_pri_key) in
		let full_message = (message, signed_message, pseudonym_cert) in
		out(pub_ch, full_message);
		event Sent_Valid_Message(full_message)
	).

let OBEReceiveMessage(pca_cert:cert) = 
	in(pub_ch, full_message:bitstring);
	let (message:bitstring, signed_message:bitstring, pseudonym_cert:cert) = full_message in
	(* Check pseudonym certificate                                               *)
	let pca_pub_key = get_cert_pub_key(pca_cert) in
	if check_cert(pseudonym_cert, pca_pub_key) = ok() then
	(* Check message signature                                                   *)
	let pseudonym_pub_key = get_cert_pub_key(pseudonym_cert) in
	if but_check_sign(signed_message, pseudonym_pub_key) = ok() then
	out(pub_ch, ());
	event Received_Valid_Message(full_message).

let PCAResponsePseudonym(pca_keymat:keymat, rootca_cert:cert, pca_cert:cert) =
	in(pub_ch, encrypted_request_from_ra:bitstring);
	let pca_pri_key = gen_pri_key(pca_keymat) in
	let request_from_ra = adec(encrypted_request_from_ra, pca_pri_key) in
	let (ra_cert:cert, obe_id:bitstring, butterfly_B:bitstring, butterfly_J:bitstring) = get_message_sign(request_from_ra) in
	let rootca_pub_key = get_cert_pub_key(rootca_cert) in
	if check_cert(ra_cert, rootca_pub_key) = ok() then
	let ra_pub_key = get_cert_pub_key(ra_cert) in
	if check_sign(request_from_ra, ra_pub_key)=ok() then
	event Test(obe_id);

	(* We know that the request_from_ra is valid                                 *)
	new c_seed:bitstring;
	let butterfly_C = but_expand(c_seed) in
	let butterfly_total = but_add(butterfly_B, butterfly_C) in
	let new_pub_key = but_to_pub_key(butterfly_total) in
	let new_cert = make_cert(obe_id, new_pub_key, pca_pri_key) in
	let response = (new_cert, new_pub_key, c_seed) in
	let butterfly_enc_key = but_to_pub_key(butterfly_J) in
	let encrypted_response = aenc(response, butterfly_enc_key) in
	out(pub_ch, encrypted_response).


let RAIntermediaryPseudonym(ra_keymat:keymat, rootca_cert:cert, eca_cert:cert, ra_cert:cert, pca_cert:cert) =
	in(pub_ch, encrypted_request_from_obe:bitstring);
	let ra_pri_key = gen_pri_key(ra_keymat) in
	let request_from_obe = adec(encrypted_request_from_obe, ra_pri_key) in
	let (obe_enrollment_cert:cert, butterfly_A:bitstring, butterfly_H:bitstring, fk:bitstring, fe:bitstring) = get_message_sign(request_from_obe) in
	let eca_pub_key = get_cert_pub_key(eca_cert) in
	if check_cert(obe_enrollment_cert, eca_pub_key)=ok() then
	let obe_pub_key = get_cert_pub_key(obe_enrollment_cert) in
	if check_sign(request_from_obe, obe_pub_key)=ok() then

	(* We know that the request_from_obe is valid                                *)
	event Received_Valid_Pseudonym_Request_RA(request_from_obe);

	let butterfly_B = but_add(butterfly_A, but_expand(fk)) in
	let butterfly_J = but_add(butterfly_H, but_expand(fe)) in
	let obe_id = get_cert_id(obe_enrollment_cert) in
	(* TODO: remove obe_id and add the two LA                                    *)
	let request = (ra_cert, obe_id, butterfly_B, butterfly_J) in
	(* let ra_pri_key = gen_pri_key(keymat) in *)
	let signed_request = sign(request, ra_pri_key) in
	let pca_pub_key = get_cert_pub_key(pca_cert) in
	let encrypted_request_for_pca = aenc(signed_request, pca_pub_key) in
	out(pub_ch, encrypted_request_for_pca);
	(* sent pseudonum cert request to PCA                                        *)

	in(pub_ch, response_pca:bitstring);
	out(pub_ch, response_pca).


let OBERequestPseudonym(obe_id:bitstring, obe_keymat:keymat, obe_enrollment_cert:cert, rootca_cert:cert, eca_cert:cert, ra_cert:cert, pca_cert:cert) = 
	new a_seed:bitstring;
	new h_seed:bitstring;
	new fk:bitstring;
	new fe:bitstring;
	let butterfly_A = but_expand(a_seed) in
	let butterfly_H = but_expand(h_seed) in
	let request = (obe_enrollment_cert, butterfly_A, butterfly_H, fk, fe) in
	let obe_pri_key = gen_pri_key(obe_keymat) in
	let signed_request = sign(request, obe_pri_key) in
	let ra_pub_key = get_cert_pub_key(ra_cert) in
	let encrypted_request_for_ra = aenc(signed_request, ra_pub_key) in
	out(pub_ch, encrypted_request_for_ra);

	event Sent_Valid_Pseudonym_Request_OBE(request);

	(* sent pseudonim cert request to RA *)

	in(pub_ch, encrypted_response_ra:bitstring);
	let butterfly_dec_key = but_to_pri_key(but_add(h_seed, fe)) in
	let response_ra = but_adec(encrypted_response_ra, butterfly_dec_key) in
	let (new_cert:cert, new_pub_key:bitstring, c_seed:bitstring) = response_ra in
	let new_pri_key = but_to_pri_key(but_add(but_add(a_seed, fk), c_seed)) in

	(* SendMessage and Receive Messages *)
	!OBESendMessages(new_cert, new_pri_key).

process
	(* Create RootCA keymaterial, public key and private key                     *)
	new rootca_keymat:keymat;
	new rootca_id:bitstring;
	let rootca_pri_key = gen_pri_key(rootca_keymat) in
	let rootca_pub_key = gen_pub_key(rootca_keymat) in
	let rootca_cert = make_cert(rootca_id, rootca_pub_key, rootca_pri_key) in
	out(pub_ch, rootca_cert);

	(* Create ECA                                                                *)
	new eca_keymat:keymat;
	new eca_id:bitstring;
	let eca_pri_key = gen_pri_key(eca_keymat) in
	let eca_pub_key = gen_pub_key(eca_keymat) in
	let eca_cert = make_cert(eca_id, eca_pub_key, rootca_pri_key) in
	out(pub_ch, eca_cert);

	(* Create RA                                                                 *)
	new ra_keymat:keymat;
	new ra_id:bitstring;
	let ra_pub_key = gen_pub_key(ra_keymat) in
	let ra_cert = make_cert(ra_id, ra_pub_key, rootca_pri_key) in
	out(pub_ch, ra_cert);

	(* Create PCA                                                                *)
	new pca_keymat:keymat;
	new pca_id:bitstring;
	let pca_pub_key = gen_pub_key(pca_keymat) in
	let pca_cert = make_cert(pca_id, pca_pub_key, rootca_pri_key) in
	out(pub_ch, pca_cert);

	(* Enrollment certificate                                                    *)
	!(
		new obe_id:bitstring;
		new obe_keymat:keymat;
		let obe_pub_key = gen_pub_key(obe_keymat) in
		let obe_enrollment_cert = make_cert(obe_id, obe_pub_key, eca_pri_key) in
		!(OBERequestPseudonym(obe_id, obe_keymat, obe_enrollment_cert, rootca_cert, eca_cert, ra_cert, pca_cert))
	)
	| !OBEReceiveMessage(pca_cert) | RAIntermediaryPseudonym(ra_keymat, rootca_cert, eca_cert, ra_cert, pca_cert) | PCAResponsePseudonym(pca_keymat, rootca_cert, pca_cert)